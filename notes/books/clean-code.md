---
layout: post
title: "Clean Code: A Handbook of Agile Software Craftsmanship"
date: 
permalink: /notes/books/clean-code
---

# Chapter 1: Clean Code

Code will exist for many years to come, whether written by humans or computer generated. It is the language in which we express requirements. The level of abstraction may continue to increase, but code will always require enough precision to meet requirements.

It is easy to write bad code - perhaps we are burdened by a deadline or just want something done so we can move on. Often, we write bad code with an intention to come back and clean it up. Except that never happens.

Good code matters because we have to deal with it. When the code is bad, attempting to implement a new feature or make a change can cause several other things to break. The total cost of maintaining code increases as more features are implemented.

Reading and maintaining bad code becomes nearly impossible to the point where products have to be axed or rewritten from the ground up. This is then a problem of itself - the original code must be maintained, with new features being developed as usual, as the new rewrite happens. The rewrite must then also implement these new features, creating a race of sorts.

There are many excuses as to why good code has become bad, but the truth is professionals should never let code become bad. We must set expectations to non-technical leaders, sales, and marketing. They can only base their promises and deadlines to customers off our commitments to them.

There will always exist deadlines. Writing messy code is an impediment to meeting these deadlines. The only way to meet these deadlines consistently is to write clean code. So what is clean code? It is elegant and efficient, handles all errors, and does one thing well.

There should be no ambiguity for what the code should do - intent and purpose are demonstrated. The code should be sufficiently optimised but not at the expense of readability and understandability. It should be minimal without unnecessary detail, yet have all of the needed abstractions.

Clean code is easy for others to read and enhance. The four rules of simple design should be adhered to: passes the tests, reveals intention, no duplication, and fewest elements. The code will then do exactly what we expect it to do - what it says it will do. 

The key to clean code is not only to write it well to begin with - we must also keep it clean. In fact, we should aim to leave the code cleaner than we found it. The code that we check in should be cleaner than the code we checked out.


# Chapter 2: Meaningful Names


# Chapter 3: Functions


# Chapter 4: Comments


# Chapter 5: Formatting


# Chapter 6: Objects and Data Structures


# Chapter 7: Error Handling

